//This script is mainly generated by Microsoft Copilot AI. It is modified to have compliance with some testing requirements.

const ELEMENT_NAMES = [
	"entry", "node", "item", "block", "section", "group", "unit", "element"
];

const VALID_ESCAPE_SEQUENCES = [
	"lt", "gt", "amp", "apos", "quote"
];

// Probability helper based on severity
function chance(severity, base) {
  return Math.random() < (severity / 10) * base;
}

function randomInt(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomString(length = 8) {
	const chars = "abcdefghijklmnopqrstuvwxyz0123456789\n";
	return Array.from({ length }, () => chars[randomInt(0, chars.length - 1)]).join("");
}

function randomAttributeValue(length = 8, severity = 0, quote, closeComment = false, closeCData = false) {
	//const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_@>!#+${][}=?\\|/£.;:€~%½()*æß 	'\"\n";
	
	var validValueChance = Math.random();
	
	//var randomAttributeValueRanges = [ {'start' : 0, 'end' : 983039} /*any character*/ ];
	
	var randomAttributeValueRanges = [ 
										{'start' : 32, 'end' : 126}, //any printable ascii character 
										{'start' : 10, 'end' : 10},	//line-feed (\n)  
										{'start' : 13, 'end' : 13},	//carriage-return (\r)
										
									 ];
	
	let _randomAttributeValue = Array.from({ length }, (value, index) => {
		
		var result = "";
		
		var charRangeIndex = 0;
		
		let randomCharRangeChance = Math.random();
		
		if(randomCharRangeChance > 0.025){
			charRangeIndex = 0;
		}
		else if(randomCharRangeChance > 0.0125){
			charRangeIndex = 1;
		}
		else{
			charRangeIndex = 2;
		}
		
		let attributeValueCharRange = randomAttributeValueRanges[charRangeIndex];
		
		let randomAttributeValueCharAsciiCode = randomInt(attributeValueCharRange['start'], attributeValueCharRange['end']);
		
		if(severity === 0 || validValueChance > 0.5){
			
			// left-angle bracket(<) and ampersand(&) characters cannot appear in attribute values
			if(randomAttributeValueCharAsciiCode === 60 || randomAttributeValueCharAsciiCode === 38){  
				randomAttributeValueCharAsciiCode = 43;  //so make it another character (like plus(+))
			}
		
			if(randomAttributeValueCharAsciiCode === quote.codePointAt(0)){
				if(quote.codePointAt(0) === 39){		//39 -> single quote(')
					randomAttributeValueCharAsciiCode = 34;
				}
				else if(quote.codePointAt(0) === 34){  // 34 -> double quote(")
					randomAttributeValueCharAsciiCode = 39;
				}
			}
		}
		
		if (Math.random() > 0.975){
			result += randomEscapeSequence(severity);
		}
		
		result += String.fromCodePoint(randomAttributeValueCharAsciiCode);
		
		return result;
		
	}).join("");

	if(!closeComment){
		_randomAttributeValue = _randomAttributeValue.replaceAll(/-[\n\r]*-[\n\r]*>/g, "+");
		_randomAttributeValue = _randomAttributeValue.replaceAll(/-[\n\r]*-[\n\r]*/g, "+");
	}
	
	if(!closeCData){
		_randomAttributeValue = _randomAttributeValue.replaceAll(/][\n\r]*][\n\r]*>/g, "+");
		_randomAttributeValue = _randomAttributeValue.replaceAll(/][\n\r]*][\n\r]*$/g, "+");
	}
	
	return _randomAttributeValue;
}

function randomText(length = 8, severity = 0, closeComment = false, closeCData = false) {
	//const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_@>!#+${][}=?\\|/£.;:€~%½()*æß 	'\"\n";
	
	var validValueChance = Math.random();
	
	//var randomTextCharRanges = [ {'start' : 0, 'end' : 983039} /*any character*/ ];	
	
	var randomTextCharRanges = [ 
								{'start' : 32, 'end' : 126}, //any printable ascii character 
								{'start' : 10, 'end' : 10},	//line-feed (\n)  
								{'start' : 13, 'end' : 13},	//carriage-return (\r) 
								];
	
	let _randomText = Array.from({ length }, (value, index) => {
		
		var result = "";
		
		var charRangeIndex = 0;
		
		let randomCharRangeChance = Math.random();
		
		if(randomCharRangeChance > 0.025){
			charRangeIndex = 0;
		}
		else if(randomCharRangeChance > 0.0125){
			charRangeIndex = 1;
		}
		else{
			charRangeIndex = 2;
		}
		
		let textCharRange = randomTextCharRanges[charRangeIndex];
		
		let randomTextCharAsciiCode = randomInt(textCharRange['start'], textCharRange['end']);
		
		if(severity === 0 || validValueChance > 0.5){
			if(closeComment && closeCData){
				// left-angle bracket(<) and ampersand(&) characters cannot appear out of comment or cdata sections
				if(randomTextCharAsciiCode === 60 || randomTextCharAsciiCode === 38){  
					randomTextCharAsciiCode = 43;  //so make it another character (like plus(+))
				}
			}
		}
		
		if (Math.random() > 0.975){
			result += randomEscapeSequence(severity);
		}
		
		result += String.fromCodePoint(randomTextCharAsciiCode);
		
		return result;
	
	}).join("");

	if(!closeComment){
		_randomText = _randomText.replaceAll(/-[\n\r]*-[\n\r]*>/g, "+");
		_randomText = _randomText.replaceAll(/-[\n\r]*-[\n\r]*/g, "+");
	}
	
	if(!closeCData || (closeCData && closeComment)){
		_randomText = _randomText.replaceAll(/][\n\r]*][\n\r]*>/g, "+");
		_randomText = _randomText.replaceAll(/][\n\r]*][\n\r]*$/g, "+");
	}
	
	return _randomText;
}

function randomTagWord(length = 8, severity = 0, closeComment = false, closeCData = false) {
	
	var name = "";
	
	var tagWordRandomizationChance = Math.random();
	
	if(severity === 0){
		
		if(tagWordRandomizationChance > 0.5){
			name = randomAttributeName(randomInt(6, length), closeComment, closeCData);
		}
		else{
			name = ELEMENT_NAMES[randomInt(0, ELEMENT_NAMES.length - 1)];
		}
	}
	else{
		if(tagWordRandomizationChance > 0.2){
			name = randomText(randomInt(6, length), severity, closeComment, closeCData);
		}
	}
	
	return name;
}

function randomAttributeName(length = 8, closeComment = true, closeCData = true) {
	
	var validAsciiStartNameCharCodeRanges = [
	{'start' : 58, 'end' : 58},		// :
	{'start' : 65,'end' : 90}, 		//A-Z
	{'start' : 95, 'end' : 95}, 	//_
	{'start' : 97, 'end' : 122}	//a-z
	//{'start' : 192, 'end' : 214}, {'start' : 216, 'end' : 246}, {'start' : 248, 'end' : 767	}, {'start' : 880, 'end' : 893},
	//{'start' : 895, 'end' : 8191}, {'start' : 8204, 'end' : 8205}, {'start' : 8304, 'end' : 8591}, {'start' : 11264, 'end' : 12271},
	//{'start' : 12289, 'end' : 55295}, {'start' : 63744, 'end' : 64975},	{'start' : 65008, 'end' : 65533},  {'start' : 65536, 'end' : 983039}
	];
	
	var validAsciiNameCharCodeRanges = [
	
	...validAsciiStartNameCharCodeRanges,
	
	{'start' : 45, 'end' : 45},		//-
	{'start' : 46,'end' : 46}, 		//.
	{'start' : 48, 'end' : 57} 	//0-9
	//{'start' : 183, 'end' : 183}, {'start' : 768, 'end' : 879}, {'start' : 8255, 'end' : 8256}
	];

	var startCharRangeLength = validAsciiStartNameCharCodeRanges.length;
	var nameCharRangeLength = validAsciiNameCharCodeRanges.length;

	let name = Array.from({ length }, (value, index) => {
		
		if(index === 0){
			let startCharRangeIndex = randomInt(0, startCharRangeLength - 1);
			let startCharRange = validAsciiStartNameCharCodeRanges[startCharRangeIndex];
			
			let randomStartCharAsciiCode = randomInt(startCharRange['start'], startCharRange['end']);
			
			return String.fromCodePoint(randomStartCharAsciiCode);
		}
		else{
			let nameCharRangeIndex = randomInt(0, nameCharRangeLength - 1);
			let nameCharRange = validAsciiNameCharCodeRanges[nameCharRangeIndex];
			
			let randomNameCharAsciiCode = randomInt(nameCharRange['start'], nameCharRange['end']);

			return String.fromCodePoint(randomNameCharAsciiCode);
			//return codePointToString(randomNameCharAsciiCode);
		}
	}).join("");

	if(!closeComment){
		name = name.replaceAll(/-[\n\r]*-[\n\r]*>/g, "+");
		name = name.replaceAll(/-[\n\r]*-[\n\r]*/g, "+");
	}
	
	if(!closeCData || (closeCData && closeComment)){
		name = name.replaceAll(/][\n\r]*][\n\r]*>/g, "+");
		name = name.replaceAll(/][\n\r]*][\n\r]*$/g, "+");
	}
		
	return name;
}

//  Namespaces (valid + corrupted)
function randomNamespaces(severity) {
	const nsList = [];

	const nsCount = randomInt(0, 3);
	
	for (let i = 0; i < nsCount; i++) {
	
	const prefix = chance(severity, 0.4)
		? ` bad!ns${randomInt(1, 99)} `
		: ` ns${randomInt(1, 99)} `;

		const uri = chance(severity, 0.4)
			? ` http://broken-uri-${randomString(5)} `
			: ` http://example.com/${randomString(5)} `;

		nsList.push(` xmlns:${prefix}="${uri}" `);
	}

	return nsList.length ? " " + nsList.join(" ") : " ";
}

//  DOCTYPE + DTD (valid + corrupted)
function randomDoctype(severity) {
	
	if (severity === 0) {
		return ` <!DOCTYPE root SYSTEM "example.dtd"> `;
	}

	const corruptForms = [
		` <!DOCTYPE root SYSTEM "missing_quote.dtd> `,
		` <!DOCTYPE root [ <!ELEMENT root ANY> <!ENTITY x "unterminated> ]> `,
		` <!DOCTYPE root [ <!ELEMENT root (child)> <!ATTLIST root bad!attr CDATA #IMPLIED> ]> `,
		` <!DOCTYPE root [ <<<<BROKEN>>>> ]> `,
		` <!DOCTYPE root SYSTEM "${randomString(20)}"> `,
		` <!DOCTYPE root [ <!ENTITY x "${randomString(50)}"> ]> `
	];

	const index = Math.min(corruptForms.length - 1, Math.floor(severity / 2));
	
	return corruptForms[randomInt(0, index)];
}

function randomAttributes(severity = 0, closeComment = false, closeCData = false) {
	const attrCount = randomInt(0, 4);
	let attrs = "";
	
	var keys = [];
	
	for (let i = 0; i < attrCount; i++) {
		var quote = "";
		
		var validAttributeChance = Math.random();
		
		if(severity === 0){
			if(validAttributeChance > 0.5){
				quote = "'";
			}
			else{
				quote = "\"";
			}
		}
		else{
			if(validAttributeChance > 0.8){
				quote = "\"";
			}
			else if(validAttributeChance > 0.6){
				quote = "'";
			}
		}
		
		var key = "";
		
		if(severity === 0){

			do{
				key = randomAttributeName(randomInt(3, 10), closeComment, closeCData);
			}
			while(keys.includes(key));
		}
		else{
			const corruptKey = chance(severity, 0.4);
			
			key = !corruptKey ? randomAttributeName(randomInt(3, 10), closeComment, closeCData)
							  : randomAttributeValue(randomInt(3, 10), severity, quote, closeComment, closeCData);
		}
		
		keys.push(key);
		
		let value = randomAttributeValue(randomInt(3, 10), severity, quote, closeComment, closeCData);

		//  EXTREME COMMENT CORRUPTION (severity-scaled)
		if (closeComment && chance(severity, 0.7)) {
		
			const commentPieces = [];

			//  1. Multiple comments inside a single attribute
			const commentCount = randomInt(1, Math.max(1, Math.floor(severity / 2)));
			
			for (let c = 0; c < commentCount; c++) {
				const commentForms = [
					` <!--${randomString(5)}${(closeComment ? '-->' : '')} `,
					` <!--${randomString(10)}-${randomInt(1000,9999)}${(closeComment ? '-->' : '')} `,
					` <!--broken-comment `,
					` <!--${randomString(5)} ${randomString(5)}${(closeComment ? '-->' : '')} `,
					` <!--${randomString(20)}${(closeComment ? '-->' : '')} `,

					//  3. Fake closing tags inside comments
					` <!-- </fake> ${(closeComment ? '-->' : '')} `,
					` <!-- </${randomString(5)}> ${(closeComment ? '-->' : '')} `,

					//  4. Fake CDATA markers
					` <!-- <![CDATA[ ${randomString(10)} ]> ${(closeComment ? '-->' : '')} `,
					` <!-- ${(closeCData ? ']]>' : '')} ${(closeComment ? '-->' : '')} `,

					//  5. Unicode / emoji chaos
					` <!-- ${randomString(5)} ${randomString(5)} ${(closeComment ? '-->' : '')} `,
					` <!-- 破壊 ${randomString(5)}  ${(closeComment ? '-->' : '')} `
				];

				const maxIndex = Math.min(
					commentForms.length - 1,
					Math.floor(severity / 1.5)
				);

				commentPieces.push(commentForms[randomInt(0, maxIndex)]);
			}

			//  2. Comments that break out of the attribute and corrupt markup
			if (chance(severity, 0.5)) {
				commentPieces.push(` ${(closeComment ? '-->' : '')} <broken attr="oops"> <!-- `);
			}

			// Combine all comment fragments
			const injected = commentPieces.join("");

			// Random placement inside the attribute value
			const placements = [
				`${injected}${value} `,
				`${value}${injected} `,
				`${value.slice(0, 2)}${injected}${value.slice(2)} `,
				`${injected} `, // attribute becomes pure chaos
				`${value}${injected}${value} ` // sandwich corruption
			];

			value = placements[randomInt(0, placements.length - 1)];
		}
		
		if(severity === 0){
			attrs += ` ${key}=${quote}${value}${quote} `;
		}
		else{
			if(validAttributeChance > 0.5){
				validAttributeChance = Math.random();
				
				if(validAttributeChance > 0.6){
					attrs += ` ${key}=${quote}${value}${quote} `;
				}
				else if(validAttributeChance > 0.4){
					attrs += ` ${key}=${quote}${value} `;
				}
				else if(validAttributeChance > 0.2){
					attrs += ` ${key}=${value}${quote} `;
				}
				else{
					attrs += ` ${key}=${value} `;
				}
			}
			else{
				if(validAttributeChance > 0.2){
					attrs += ` ${key}=${value} `;
				}
				else{
					attrs += ` ${key} ${value} `;
				}
				
				//Duplicate attribute corruption
				if (chance(severity, 0.3)) {
					attrs += ` ${key}="duplicate" `;
				}
			}
		}
	}

	return attrs;
}

function recursiveCommentValid(depth, maxDepth, initialSeverity = 0, severity = 0, closeComment = true, closeCData = true) {
	
	var out = "";
	
	if(depth >= maxDepth){
		return out;
	}
	
	const _depth = randomInt(1, Math.max(1, Math.floor(severity / 2)));

	out = ` <!${(closeComment ? '--' : '')} `;

	//  Simulated recursive comment layers (never real nested comments)
	for (let i = 0; i < _depth; i++) {
		out += '  [SIMULATED-COMMENT-LEVEL-' + i + ': ' + randomString(randomInt(8, 80)) + ' ] \n ';
	}

	//  Add safe complexity fragments
	const fragments = [
		`fake-tag: <${randomString(5)} attr="${randomString(4)} /> `,
		`fake-tag2: <${randomString(5)} attr"${randomString(4)} /> `,
		`fake-tag3: <${randomString(5)} attr'${randomString(4)} /> `,
		`fake-tag4: <${randomString(5)} attr"${randomString(4)} > `,
		`fake-tag5: <${randomString(5)} attr'${randomString(4)} > `,
		`fake-tag6: <${randomString(5)} "${randomString(4)} > `,
		`fake-tag7: <${randomString(5)} '${randomString(4)} > `,
		`fake-tag8: <${randomString(5)} ${randomString(4)}' > `,
		`fake-tag9: <${randomString(5)} ${randomString(4)}" > `,
		`fake-tag10: <${randomString(5)} attr=${randomString(4)}" > `,
		`fake-tag11: <${randomString(5)} attr=${randomString(4)}' > `,
		`fake-tag12: <${randomString(5)} attr${randomString(4)}' > `,
		`fake-tag13: <${randomString(5)} attr${randomString(4)}' /> `,
		`fake-tag14: <${randomString(5)} 9attr${randomString(4)}' /> `,
		`fake-tag15: <${randomString(5)} 9attr='${randomString(4)}' /> `,
		`fake-tag16: <${randomString(5)} 9attr="${randomString(4)}" /> `,
		`fake-close: </${randomString(5)}> `,
		`fake-close2: </${randomString(5)} `,
		`fake-cdata: <![CDATA[ ${randomString(10)} ` + (closeCData ? ` ]]> ` : ' '),
		`fake-cdata2: <![CDATA[ ${randomString(10)} `,
		`fake-cdata3: <![CDATA[ ${randomString(10)} ]> `,
		`fake-cdata4: <![CATA[ ${randomString(10)} ]> `,
		`fake-cdata5: <[CDATA[ ${randomString(10)} ]> `,
		`fake-cdata6: <CDATA[ ${randomString(10)} ` + (closeCData ? ` ]]> ` : ''),
		`fake-doctype: <!DOCTYPE ${randomString(5)}> `,
		`fake-pi: <?xml version="9.${randomInt(0,9)} `,
		`unicode: `,
		`surrogate-high: \\uD8${randomInt(10,99)} `,
		`surrogate-low: \\uDC${randomInt(10,99)} `,
		`null-byte: \\0 `,
		`control-char: \\u00${randomInt(10,99)} `
	];

	const count = randomInt(1, Math.max(1, severity));
	
	for (let i = 0; i < count; i++) {
		const frag = fragments[randomInt(0, fragments.length - 1)];
		out += `  ${frag} `;
	}

	//  Simulated recursive block (still valid)
	if (severity > 3) {
		out += '  <<<SIMULATED-RECURSION-START>>> \n ';
		
		for (let i = 0; i < _depth; i++) {
		  out += `    level-${i}: ${randomString(randomInt(12, 100))} `;
		}
		
		out += '  <<<SIMULATED-RECURSION-END>>> \n ';
	}

	severity = Math.random() < 0.5 ? 0 : randomInt(1, 10);
	
	out += generateNode(depth + 1, maxDepth, 3, initialSeverity, severity, false, closeCData);

	//  Close comment cleanly
	if(closeComment){
		out += " --> ";
	}
 
  return out;
}

//  Comments
function randomComment(depth, maxDepth, initialSeverity = 0, severity = 0, closeComment = true, closeCData = true) {
	
	var out = "";
	
	if(depth >= maxDepth){
		return out;
	}
	
	if(severity === 0){
		out = recursiveCommentValid(depth, maxDepth, initialSeverity, severity, closeComment, closeCData);
	}
	else{
		const sentences = [
			` Generated=${new Date().toISOString()} `,
			` Seed=${randomInt(10000, 99999)} `,
			` TraceID:${randomString(12)} `,
			` Meta={"flag":${Math.random() > 0.5}, "count":${randomInt(1, 50)}} `,
			` Note:${randomString(6)}-${randomString(6)} `
		];

		out = ` <!${(closeComment ? '--' : '')} ${sentences.slice(0, randomInt(2, 5)).join(" | ")} `;
		
		var closeCommentChance = initialSeverity === 0 ? closeComment : (Math.random() > 0.5 ? true : false);
		var closeCDataChance = initialSeverity === 0 ? closeCData : (Math.random() > 0.5 ? true : false);
		
		severity = Math.random() < 0.5 ? 0 : randomInt(1, 10);
		
		if(severity === 0){
			out += generateNode(depth, maxDepth, 3, initialSeverity, severity, false, closeCDataChance);
			
			if(closeComment){
				out += " --> ";
			}
		}
		else{
			out += generateNode(depth, maxDepth, 3, initialSeverity, severity, closeCommentChance, closeCDataChance);
			
			if(closeCommentChance && closeComment){
				out += " --> ";
			}
		}
	}

	return out;
}

function recursiveCdataValid(depth, maxDepth, initialSeverity = 0, severity = 0, closeCData = true, closeComment = true) {
	
	var out = "";
	
	if(depth >= maxDepth){
		return out;
	}
	
	const _depth = randomInt(1, Math.max(1, Math.floor(severity / 2)));

	 out = " <![CDATA[ ";

	//  Simulated recursive CDATA layers (escaped safely)
	for (let i = 0; i < _depth; i++) {
		//out += `  <![CDATA[ simulated-level-${i}-${randomString(6)} ]]>\n`;
		out += '  <![CDATA[ simulated-level-' + i + '-' + randomString(randomInt(6, 80)) + ' \n ';
	}

	//  Safe complexity fragments (all valid inside CDATA)
	const fragments = [
		` <fakeTag attr="${randomString(5)}"/> `,
		` <inner><nested>${randomString(10)}</nested></inner> `,
		` <?xml version="9.${randomInt(0,9)}" weird="true"?> `,
		` <!DOCTYPE fake SYSTEM "fake${randomInt(1,99)}.dtd"> `,
		` surrogate-high: \\uD8${randomInt(10,99)} `,
		` surrogate-low: \\uDC${randomInt(10,99)} `,
		` null-byte: \\0 `,
		` control-char: \\u00${randomInt(10,99)} `
	];

	//  Add severity-scaled complexity
	const count = randomInt(1, Math.max(1, severity));
	
	for (let i = 0; i < count; i++) {
		const frag = fragments[randomInt(0, fragments.length - 1)];
		out += `  ${frag}`;
	}

	//  Simulated recursive structures (still safe)
	if (severity > 3) {
		
		out += '  <<<SIMULATED-RECURSION-START>>> \n ';
		
		for (let i = 0; i < _depth; i++) {
			out += '    level-' + i + ': ' + randomString(randomInt(12, 80)) + ' \n ';
		}
		
		out += '  <<<SIMULATED-RECURSION-END>>> \n ';
	}

	severity = Math.random() < 0.5 ? 0 : randomInt(1, 10);

	out += generateNode(depth + 1, maxDepth, 3, initialSeverity, severity, closeComment, false);
	
	if(closeCData){
		out += ' ]]> ';
	}

	return out;
}


function randomCdata(depth, maxDepth, initialSeverity = 0, severity = 0, closeCData = true, closeComment = true) {
  
  var out = "";
  
	if(depth >= maxDepth){
		return out;
	}
	
	if (severity === 0) {
		out = recursiveCdataValid(depth, maxDepth, initialSeverity, severity, closeCData, closeComment); 
	}
	else {
		var closeCommentChance = initialSeverity === 0 ? closeComment : (Math.random() > 0.5 ? true : false);
		var closeCDataChance = initialSeverity === 0 ? closeCData : (Math.random() > 0.5 ? true : false);

		severity = Math.random() < 0.5 ? 0 : randomInt(1, 10);
		
		if(severity === 0){
			out = " <![CDATA[ ";
			out += generateNode(depth, maxDepth, 3, initialSeverity, severity, closeCommentChance, false);
			
			if(closeCData){
				out += ' ]]> '; 
			}
		}
		else{
			out = " <![CDATA[ ";
			
			out += generateNode(depth, maxDepth, 3, initialSeverity, severity, closeCommentChance, closeCDataChance);
			
			if(severity > 0){
				out += ` ${recursiveCdataBreakout(severity, closeCDataChance, closeCommentChance)} `;
			}
			
			if(closeCDataChance && closeCData){
				out += ' ]]> ';
			}
		}
	}
  
  return out;
}

function randomEscapeSequence(severity = 0){
	
	var out = "";
	
	let validEscapeSequenceChance = Math.random();
	
	if(severity === 0 || validEscapeSequenceChance > 0.6){
		
		let randomValidSequenceIndex = randomInt(0, VALID_ESCAPE_SEQUENCES.length - 1);
		
		var sequence = VALID_ESCAPE_SEQUENCES[randomValidSequenceIndex];
		
		out += "&";
		out += sequence;
		out += ";"
	}
	else{
		if(validEscapeSequenceChance > 0.3){
			let randomValidSequenceIndex = randomInt(0, VALID_ESCAPE_SEQUENCES.length - 1);
		
			var sequence = VALID_ESCAPE_SEQUENCES[randomValidSequenceIndex];
		
			out += "&";
			out += sequence;
		}
		
		else if(validEscapeSequenceChance > 0.15){
			var sequence = randomString(randomInt(2,5));
		
			out += "&";
			out += sequence;
		}
		else{
			out += "&";
		}
	}
	
	return out;
}

// Mixed content
function randomMixedContent(depth, maxDepth, initialSeverity = 0, severity = 0, closeComment = true, closeCData = true) {
	
	if(depth >= maxDepth){
		return "";
	}
	
	const parts = [];

	if (Math.random() > 0.5) parts.push(randomText(randomInt(5, 350), severity, closeComment, closeCData));
	if (Math.random() > 0.7) parts.push(randomCdata(depth + 1, maxDepth, initialSeverity, severity, closeCData, closeComment));
	if (Math.random() > 0.5) parts.push(randomText(randomInt(5, 350), severity, closeComment, closeCData));

	if (chance(severity, 0.5)) {
		parts.push(randomText(randomInt(100, 350), severity, closeComment, closeCData));
	}
  
	if (chance(severity, 0.7)) {
	  parts.push(recursiveComment(severity, closeComment));
	}

	if (chance(severity, 0.7)) {
	  parts.push(recursiveCdata(severity, closeCData));
	}

	if (chance(severity, 0.5)) {
	  parts.push(recursiveCdataBreakout(severity, closeCData, closeComment));
	}

  return parts.join(" ");
}

function recursiveCdataBreakout(severity, closeCData = false, closeComment = false) {
  
  const depth = randomInt(1, Math.max(1, Math.floor(severity / 2)));

  let cdata = " <![CDATA[ ";

  // Build recursive CDATA illusion
  for (let i = 0; i < depth; i++) {
    cdata += ` <![CDATA[ level${i}-${randomString(5)} `;
  }

  // Insert core payload
  cdata += ` ${randomString(20)} `;

  // Now the breakout corruption
	if (severity > 0) {
		const breakoutFragments = [
		  ` ${(closeCData ? ']]>' : '')} <broken tag="${randomString(5)}"> <!${(closeComment ? '--' : '')} oops${(closeComment ? '-->' : '')} `,
		  ` ${(closeCData ? ']]>' : '')} </fake${randomInt(1,99)}> <![CDATA[ `,
		  ` ${(closeCData ? ']]>' : '')} <${randomString(5)} bad="true"> `,
		  ` ${(closeCData ? ']]>' : '')} <!${(closeComment ? '--' : '')} corrupted ${(closeComment ? '-->' : '')} <${randomString(4)}> `,
		  ` ${(closeCData ? ']]>' : '')} <inject attr="<!${(closeComment ? '--' : '')}${randomString(5)}${(closeComment ? '-->' : '')}"> `
		];

		const maxIndex = Math.min(
		  breakoutFragments.length - 1,
		  Math.floor(severity / 2)
		);

		// Add 1–N breakout fragments depending on severity
		const breakoutCount = randomInt(1, Math.max(1, Math.floor(severity / 2)));
		
		for (let i = 0; i < breakoutCount; i++) {
		  cdata += breakoutFragments[randomInt(0, maxIndex)];
		}
	}

	if(closeCData){
		// Close remaining CDATA layers (intentionally mismatched)
		for (let i = 0; i < depth; i++) {
			cdata += " ]]> ";
		}

		// Final corrupted close
		if (severity > 5 && Math.random() > 0.4) {
			cdata += ` ]]> ]]> >>>> `;
		}
	}
	
	return cdata;
}


function recursiveComment(severity = 0, closeComment = true) {
	
	const depth = randomInt(1, Math.max(1, Math.floor(severity / 2)));

	let comment = ` <!${(closeComment ? '--' : '')} `;

	for (let i = 0; i < depth; i++) {
		comment += ` level${i} <!${(closeComment ? '--' : '')} `;
	}
	
	comment += ` ${randomString(randomInt(10, 80))} `;

	if(severity > 0 && closeComment){
		var closeCommentChance = Math.random();
		
		if(closeCommentChance > 0.5){
			for (let i = 0; i < depth; i++) {
				comment += ` --> \n `;
			}
		}
	}

	if(closeComment){
		comment += " --> \n ";
	}
  
  return comment;
}


function recursiveCdata(severity = 0, closeCData = true) {
	const depth = randomInt(1, Math.max(1, Math.floor(severity / 2)));

	let cdata = " <![CDATA[ ";
	
	for (let i = 0; i < depth; i++) {
		cdata += ` <![CDATA[ `;
	}

	cdata += randomString(randomInt(20, 90));

	if(severity > 0 && closeCData){
		var closeCDataChance = Math.random();
		
		if(closeCDataChance > 0.5){
			for (let i = 0; i < depth; i++) {
				cdata += " ]]> \n ";
			}
		}
	}

	if(closeCData){
		cdata += " ]]> \n ";
	}
  
  return cdata;
}


//  Recursive node generator
function generateNode(depth, maxDepth, maxChildren, initialSeverity = 0, severity = 0, closeComment = true, closeCData = true) {
	let xml = "";
	
	maxDepth = parseInt(Math.max(Math.random(), 0.56) * maxDepth);
	
	const name = randomTagWord(20, severity, closeComment, closeCData);
	const attrs = randomAttributes(severity, closeComment, closeCData);

	const corruptOpen = chance(severity, 0.4);
	const corruptClose = chance(severity, 0.4);
	
	var isEmptyElement = false;
	
	if(Math.random() > 0.95){
		isEmptyElement = true;
	}
	
	var openTag = "";
	var closeTag = "";
		
	if(corruptOpen){
		var corruptionTypeChance = Math.random();
		
		if(corruptionTypeChance > 0.8){
			openTag = '<' + name + '!' + attrs;
		}
		else if(corruptionTypeChance > 0.6){
			openTag = name + attrs;
		}
		else if(corruptionTypeChance > 0.4){
			openTag = '<' + name + attrs;
		}
		else if(corruptionTypeChance > 0.2){
			openTag = name + attrs;
		}
		else{
			openTag = '<' + name + attrs;
		}
		
		if(corruptionTypeChance < 0.5 && !isEmptyElement){
			openTag += '>';
		}
	}
	else{
		openTag = '<' + name + attrs;
		
		if(!isEmptyElement){
			openTag += '>';
		}
		else{
			openTag += ' ';
		}
	}
	
	if(corruptClose){
		var corruptionTypeChance = Math.random();
		
		if(!isEmptyElement){
			
			if(corruptionTypeChance > 0.8){
				closeTag = `${randomString(5, 15)}`;
			}
			else if(corruptionTypeChance > 0.6){
				closeTag = `</${randomString(5, 15)}` + name;
			}
			else if(corruptionTypeChance > 0.4){
				closeTag = `<${randomString(5, 15)}` + name + '>';
			}
			else if(corruptionTypeChance > 0.2){
				closeTag = name + '>';
			}
			else{
				closeTag = '</' + name + '>';
			}
		}
		else{
			if(corruptionTypeChance > 0.7){
				closeTag = '';
			}
			else if (corruptionTypeChance > 0.5){
				closeTag = '>';
			}
			else{
				closeTag = '/>';
			}
		}
	}
	else{
		if(!isEmptyElement){
			closeTag = '</' + name + '>';
		}
		else{
			closeTag += '/>';
		}
	}
	
	if (depth < maxDepth && Math.random() > 0.7) {
		xml += `  ${randomComment(depth + 1, maxDepth, initialSeverity, severity, closeComment, closeCData)} `;
	}
	
	xml += ' ' + openTag + ' ';
	
	if(!isEmptyElement){

		if (Math.random() > 0.4 && depth < maxDepth) {
			xml += `    ${randomMixedContent(depth + 1, maxDepth, initialSeverity, severity, closeComment, closeCData)} `;
		}

		if (depth < maxDepth) {
			const childCount = randomInt(0, maxChildren);
			
			for (let i = 0; i < childCount; i++) {
				xml += generateNode(depth + 1, maxDepth, maxChildren, initialSeverity, severity, closeComment, closeCData);
			}
		}
	}
	
	xml += ' ' + closeTag + ' \n ';	
	
	return xml;
}

/*
	Severity Levels:
	0 	-> Fully valid XML, no corruption
	1–3 -> Light corruption (occasional junk, mild CDATA issues)
	4–6 -> Moderate corruption (broken tags, illegal chars, mismatches)
	7–9 -> Heavy corruption (multiple structural issues)
	10  -> Maximum chaos (almost guaranteed invalid XML)
*/
//  Main generator
function generateRandomXML(maxDepth = 3, maxChildren = 3, severity = 0) {
	//const ns = randomNamespaces(severity);
	//const doctype = randomDoctype(severity);
	
	var initialSeverity = severity;
	
	var closeComment = true;
	var closeCData = true;
	
	if(severity > 0){
		closeComment = Math.random() > 0.5 ? true : false;
		closeCData = Math.random() > 0.5 ? true : false;
	}
	
	let xml = "";
	
	if(severity === 0){
		xml += '<?xml version="1.0" encoding="UTF-8"?> \n ';
	}
	
  //xml += `${doctype}\n`;

	const name = randomTagWord(20, severity, closeComment, closeCData);
	const attrs = randomAttributes(severity, closeComment, closeCData);
	
	const corruptOpen = chance(severity, 0.4);
	const corruptClose = chance(severity, 0.4);
	
	var isEmptyElement = false;
	
	if(Math.random() > 0.95){
		isEmptyElement = true;
	}

	var openTag = "";
	var closeTag = "";
		
	if(corruptOpen){
		var corruptionTypeChance = Math.random();
		
		if(corruptionTypeChance > 0.8){
			openTag = '<' + name + '!' + attrs;
		}
		else if(corruptionTypeChance > 0.6){
			openTag = name + attrs;
		}
		else if(corruptionTypeChance > 0.4){
			openTag = '<' + name + attrs;
		}
		else if(corruptionTypeChance > 0.2){
			openTag = name + attrs;
		}
		else{
			openTag = '<' + name + attrs;
		}
		
		if(corruptionTypeChance < 0.5 && !isEmptyElement){
			openTag += '>';
		}
	}
	else{
		openTag = '<' + name + attrs;
		
		if(!isEmptyElement){
			openTag += '>';
		}
		else{
			openTag += ' ';
		}
	}
	
	if(corruptClose){
		var corruptionTypeChance = Math.random();
		
		if(!isEmptyElement){
			
			if(corruptionTypeChance > 0.8){
				closeTag = `${randomString(5, 15)}`;
			}
			else if(corruptionTypeChance > 0.6){
				closeTag = `</${randomString(5, 15)}` + name;
			}
			else if(corruptionTypeChance > 0.4){
				closeTag = `<${randomString(5, 15)}` + name + '>';
			}
			else if(corruptionTypeChance > 0.2){
				closeTag = name + '>';
			}
			else{
				closeTag = '</' + name + '>';
			}
		}
		else{
			if(corruptionTypeChance > 0.7){
				closeTag = '';
			}
			else if (corruptionTypeChance > 0.5){
				closeTag = '>';
			}
			else{
				closeTag = '/>';
			}
		}
	}
	else{
		if(!isEmptyElement){
			closeTag = '</' + name + '>';
		}
		else{
			closeTag += '/>';
		}
	}
	
	var topComments = randomInt(0, 3);

	for (let i = 0; i < topComments; i++) {
		xml += randomComment(1, 4, initialSeverity, severity, closeComment, closeCData);
	}
	
	xml += ' ' + openTag + ' \n ';

	if(!isEmptyElement){
		
		if (Math.random() > 0.3) {
			xml += "  <meta>    " + randomCdata(1, 4, initialSeverity, severity, closeCData, closeComment) + " </meta> ";
		}

		xml += generateNode(1, maxDepth, maxChildren, initialSeverity, severity, closeComment, closeCData);	
	}
	
	xml += ' ' + closeTag + ' \n ';

	topComments = randomInt(0, 3);

	for (let i = 0; i < topComments; i++) {
		xml += randomComment(1, 4, initialSeverity, severity, closeComment, closeCData);
	}
	
	return xml;
}

module.exports = { generateRandomXML }